---
title: What is TypedQL Builder?
id: 4i3PCEkW6nmiPsUiM4N1qF
status: DRAFT
createdAt: 2019-03-11T15:24:00.191Z
updatedAt: 2020-03-13T21:24:58.105Z
publishedAt: 
firstPublishedAt: 2019-03-11T15:27:46.068Z
contentType: tutorial
productTeam: VTEX IO
author: 3aBBTLS9ZKO6IcY0Goe2y2
slug: understanding-typedql-builder
legacySlug: typeql-builder
subcategory: Z46a6rHVAaAucoiW0skQQ
---

# TypeQL Builder

TypedQL Builder is a VTEX IO feature for developing backend projects.

Similar to GraphQL Builder, it comes as an alternative to backend apps written in GraphQL + TypeScript. It proposes to be more modern and generic, using only TypeScript Type Declaration files to create the GraphQL interface automatically.

With this, TypeScript-based projects are greatly benefited by the use of this Builder. When developing a backend project using TypeScript + GraphQL, the developer needs to write a set of TypeScript types to typify the behavior of their Resolvers but at the same time writing GraphQL Schemas using GraphQL SDL.

With TypedQL Builder, the developer needs to write only TypeScript types. GraphQL Schema is automatically generated. Some advantages of this feature are:

### 1. Unification of the protocol description

Using GraphQL Builder, any modification to the Schema interface (TypeScript) must reflect in a TypeScript (Schema) update. This makes the process prone to failures, which does not happen if Schema is autogenerated by TypedQL Builder.

### 2. Reduction of code

This same condition causes the developer to write the same interface twice. Using TypedQL's automatic transpilation reduces your effort by half and you don't have to worry about learning the syntax of a new language.

### 3. Encouraging typing, discouraging inconsistency

The need to write TypeScript interfaces for resolvers encourages typing them appropriately and automatically according to the GraphQL description. This discourages inconsistencies such as using GraphQL Fields as `Nullable` unnecessarily.

### 4. Access to TypeScript functions not allowed in GraphQL

This allows you to describe complex Schemas much more easily and quickly. Some examples of usable TypeScript features are:

- __Inheritance__: Create GraphQL Types using previous code;
- __Unions with unions__: Combining TypeScript Unions with each other to generate GraphQL Unions in a scalable way;
- __Unions with enums__: Combining TypeScript Enums with unions to generate GraphSQL Enums in a scalable way;
- __Import and Export__: Divide your definitions into multiple files, exposing and searching only what you need.

## Basic Operation

To use TypedQL Builder just add it to the Builders list of your `manifest.json`, like this:

```js
//[...]
"builders": {
  "typedql": "0.x"   
}
//[...]
```

Builder will look for a `typedql/` folder located at the root of your project. Inside it there should be a `schema.ts` file which is the entry point for the `Query` and `Mutation` definitions of your app. For a classic **Hello World!** put in the `schema.ts`:

```ts
/** @graphql ID */
type ID = string

interface World {
    id: ID
}
interface Query {
    hello: World
}
```
Which should generate the Schema:

```gql
type World {
    id: ID!
}

type Query {
    hello: World!
}

schema {
    query: Query
}
```

TypedQL Builder will always look for the declaration of the `Query` and `Mutation` interfaces in `schema.ts`, from which it will generate the standard Query and Mutation types of the GraphQL SDL. TypedQL Builder only issues types that are in some way used by `Query` and `Mutation`, or as Field Resolver, as property, parameter in list of arguments, return of function, etc.

You can split your Type Declarations into multiple files, using `export` to expose to external files and `import` to import from external files.
To make TypedQL Builder ignore some line of code, create inline comments with `//`.

## TypedQL Migrator

VTEX has developed an example app called **TypedQL Migrator** to assist in the rapid test of converting TypeScript declarations to GraphQL Schema.

To use it, simply have the VTEX CLI installed and type in the command line:

```sh
vtex install vtex.typedql-migrator
```
This should install the app in the current workspace. You can access the tool here:

`<workspace>--<account>.myvtex.com/typedqlmigrator`

## Features

GraphQL SDL and TypeScript Type Declarations have large but not total intersection. GraphQL's own concepts that do not have an intuitive TypeScript equivalent are reported to the transpiler using **JSDoc** and the special annotation `@graphql <Marking>`. The following table shows tags comprised by the transpilator.

| GraphQL Concept | JSDoc Marking |
| ---------------- |: -------------: |
| ID | `@graphql ID` |
| Int | `@graphql Int` |
| Float | `@graphql Float` |
| Input | `@graphql Input` |
| Field Directives | `@graphql Directives` |

#### GraphQL Scalars

There are 5 primitive types in GraphQL: `ID`, `Int`, `Float`, `Boolean` and `String`. Its TypeScript equivalents, of course, are `string`, `number`, `number`, `boolean` and `string`. This creates certain ambiguities that need to be removed using **JSDoc** to achieve the desired result. For example:
```
/** @graphql ID */
type ID = string
/** @graphql Int */
type Int = number
/** @graphql Float */
type Float = number
interface Foo {
    a: ID,
    b: number,
    c: Int,
    d: Float,
    e: boolean,
    f: string
}
```
It is converted to:

```
type Foo {
    a: ID!
    b: Float!
    c: Int!
    d: Float!
    e: Boolean!
    f: String!
}
```
#### GraphQL Object Types, Fields, and Arguments

As already shown, a GraphQL Type can be described by a TypeScript Interface. The properties of an Interface are `Required` by default. To remove this behavior it's necessary to join the type with `null` or `undefined` or, in the case of argument lists and interface properties, with the token `?`.

```ts
/** @graphql ID */
type ID = string
/** @graphql Int */
type Int = number

interface IDCollection {
    id1: ID
    id2: ID | undefined
    id3: ID | null
    id4?: ID
    getId(which: Int): ID | undefined
    getIds(from: Int, to: Int): (ID | null)[] | null
    getNullableIds: (ID | undefined)[]
    getNonNullableIds(from: Int, to: Int | null): ID[] | null
}
```

It is transpilated to:

```gql
type IDCollection {
    id1: ID!
    id2: ID
    id3: ID
    id4: ID
    getId(which: Int!): ID
    getIds(from: Int!, to: Int!): [ID]
    getNullableIds: [ID]!
    getNonNullableIds(from: Int!, to: Int): [ID!]
}
```

#### Heritage

Types can be combined with each other without discrimination. You can also use inheritance to combine Types although GraphQL does not support this feature.

```ts
/** @graphql Int */
type Int = number

interface Tire {
    diameter: number,
    material: string
}

interface Vehicle {
    numTires: Int
    getTires: Tire[]
}

interface MotorCycle extends Vehicle {
    hasSideCar: boolean
}

interface Car extends Vehicle {
    getLeftTires: Tire[]
    getRightTires: Tire[]
}
```

Creates:

```
type Tire {
  diameter: Float!
  material: String!
}

type Vehicle {
  getTires: [Tire!]!
  numTires: Int!
}

type Car {
  getLeftTires: [Tire!]!
  getRightTires: [Tire!]!
  getTires: [Tire!]!
  numTires: Int!
}

type MotorCycle {
  getTires: [Tire!]!
  hasSideCar: Boolean!
  numTires: Int!
}
```

#### GraphQL Interfaces

Although TypeScript does not support multiple inheritance, it supports interfaces, just like GraphQL. For a type to be issued as a GraphQL Interface, however, it can not be property of some TypeScript Interface or return of any method. In this case TypedQL automatically realizes the need for the type to be concrete and issues an appropriate GraphQL Type.

```ts
type Noise {
  duration: number
  intensity: number
}
interface Noisy {
    makeNoise: Noise
}
interface Dirty {
    dirtyLevel: number
}
interface Car extends Noisy, Dirty {
    gasLevel: number
}

interface Query {
    getCar: Car
}
```
```gql
type Noise {
  duration: Float!
  intensity: Float!
}
interface Noisy {
    makeNoise: Noise!
}
interface Dirty {
    dirtyLevel: Float!
}
type Car {
    dirtyLevel: DirtyLevel!
    gasLevel: Float!
    makeNoise: Noise!
}
type Query {
    getCar: Car!
}
```

#### GraphQL Enums

TypeScript Enums are directly equivalent to GraphQL Enums:

```ts
enum DirtyLevel {
    LOW,
    MEDIUM,
    HIGH
}
interface Dirty {
    dirtyLevel: DirtyLevel
}
```
```
enum DirtyLevel {
    LOW
    MEDIUM
    HIGH
}
type Dirty {
    dirtyLevel: DirtyLevel!
}
```

It is not possible to combine Enums in GraphQL, but TypedQL Builder is able to recognize enums, creating combinations automatically:

```ts
declare enum HotColors {
    RED,
    YELLOW,
}
declare enum ColdColors {
    BLUE,
    GREEN,
}
type Colors = HotColors | ColdColors
```
```gql
enum HotColors {
    RED,
    YELLOW
}
enum ColdColors {
    BLUE,
    GREEN
}
enum Colors {
    RED,
    YELLOW,
    BLUE,
    GREEN,
}
```

#### GraphQL Unions

GraphQL supports merging GraphQL Objects as a single type, such as TypeScript. However, TypeScript Unions can be interpreted in different ways depending on the objects involved and can be easily interpreted. Check out the **Disclaimers** section for examples. In general, GraphQL Unions are valid between Object Types.

```ts
/** @graphql ID */
type ID = string
interface Book {
    id: ID
}
interface Magazine {
    id: ID
}
type SellItem = Book | Magazine
interface Bookstore {
    sell(id: ID) => SellItem
}
```

Transpilates to:

```
type Book {
    id: ID!
}
type Magazine {
    id: ID!
}
union SellItem = Book | Magazine
type Bookstore {
    sell(id: ID!): SellItem!
}
```

#### GraphQL Field Directives

Directives are a powerful feature of GraphQL that currently have no TypeScript equivalent. TypedQL Builder supports the description of Field Directives through **JSDoc** as shown in the example below. All JSDoc Tags described under `@graphql Directives` are interpreted as GraphQL Directives. This feature is very important, for example, to make use of features of Apollo GraphQL.

```ts
interface Store {
    /** @graphql Directives
    *   @cacheControl (scope: PUBLIC, maxAge: 14400)
    *   @filter (pattern: "vtex-io")
    */
    product(slug: string): Product
    /** @graphql Directives
    *   @smartcache
    *   @filter (pattern: "vtex-io")
    */
    products: Product[]
}
```
```gql
type Store {
    product(slug: String!): Product! @cacheControl(scope:PUBLIC, maxAge:14400)
    products: [Product!]! @smartcache @filter(pattern:"vtex-io")
}
```

Currently TypedQL Builder accepts as arguments of the directves **Named Type**, **String Literai**, **Int**, **Float** and **Boolean** of GraphQL SDL.

#### GraphQL Input

GraphQL Input Objects differ from Type Objects because their Fields can not have argument lists and can only be used as arguments of a Type Object Field. There is no similar restrictive concept in TypeScript, so you have to annotate interfaces to warn the compiler that an interface is an input.

```ts
/** @graphql input */
interface SomeInput {
    someValue: boolean
}
interface Foo {
    bar(ham: SomeInput) => boolean
}
```
```gql
input SomeInput {
    someValue: Boolean!
}
type Foo {
    bar(ham: SomeInput!): Boolean!
}
```

## Disclaimers

There is a large intersection between typing TypeScript Type Declarations and GraphQL SDL, so the TypeScript equivalent of a GraphQL Schema should be intuitive. However, there are some use cases and concepts that may be counterintuitive.

#### There is no alias in GraphQL SDL

Although in TypeScript it's possible to create aliases of primitive types such as:

```ts
type StringAlias = string
```

This is not a feature supported in GraphQL and it's actually interpreted as the declaration of a **Custom Scalar**, where the internal implementation of the backend treats `StringAlias` as a `string`.

```gql
scalar StringAlias
```

For non-primitive types, however, it's possible to do something equivalent to an alias using `union`, so:

```ts
interface SomeType {
    foo: boolean!
}
type SomeTypeAlias = SomeType
```
Is translated to:

```gql
type SomeType {
    foo: Boolean
}
union SomeTypeAlias = SomeType
```

However, for convenience, TypedQL Builder recognizes the union of Scalars and Object Types with `null` and `undefined` as Syntatic Sugar for NotNull Wrapping of GraphQL. In other words:

```ts
type NullableString = string | null
interface Return {
    content: NullableString
}
type NullableReturn = Return | undefined
interface Foo {
    bar: NullableReturn
}
```
Is interpreted as:

```gql
type Return {
    content: String
}
type Foo {
    bar: Return
}
```

#### Interface Properties, Parameters, and Function Returns are issued Required by default

Although in GraphQL SDL, Fields and Arguments are not Required by default and you need to add `!` to make them Required, the behavior in TypeScript is just the opposite. If a function is defined to receive 3 parameters, it **requires** that you add three parameters and if an Interface has a certain property, it **requires** that this is not undefined.

#### Unions in TypeScript do not need to be named as they do in GraphQL 

In other words:

```ts
/** @graphql ID */
type ID = string
interface A {
    id: ID
}
interface B {
    id: ID
}
interface C {
    c: A | B
}
```
Is valid in TypeScript but not in GraphQL SDL. To get the desired behavior we would have to do:

```ts
/** @graphql ID */
type ID = string
interface A {
    id: ID
}
interface B {
    id: ID
}
type UnionAB = A | B
interface C {
    c: UnionAB
}
```

Getting:

```gql
type A {
    id: ID!
}
type B {
    id: ID!
}
union UnionAB = A | B
type C {
    c: UnionAB!
}
```

#### GraphQL does not support empty types

In TypeScript you can create Interfaces without any properties, simply due to naming issues. In GraphQL this is not accepted. To work around it, TypedQL Builder adds a "placeholder" field just to ensure Type creation. That is:

```ts
interface Empty {
    
}
```

To facilitate the performance of tests, is converted into:

```gql
type Empty {
   __placeholder: Boolean 
}
```

#### GraphQL does not accept Scalars, Interfaces, and Unions in a Union declaration

Although the constructs below are fully valid in TypeScript, they will generate errors when attempting to convert to a GraphQL Schema using TypedQL Builder.

```ts
type ScalarsUnion = number | boolean // Not accepted
type interface Foo {
    foo: string
}
type interface Bar extends Foo {
    bar: string
}
type interface Quux {
    quux: string
}
type UnionUnion = ScalarsUnion | Bar // Not accepted
type InterfaceUnion = Foo | Quux // Not accepted
interface Query {
    getBar: Bar
}
```

## Reference

https://facebook.github.io/graphql/June2018
https://www.typescriptlang.org/docs
